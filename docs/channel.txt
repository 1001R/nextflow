#######
Channel
#######

Nextflow is based on the Dataflow programming model in which processes communicate through channels.

A `channel` is a non-blocking unidirectional FIFO queue which connects two processes.

The channel has the property that sending a message is an `asynchronous` operation which completes immediately,
without any interaction with or waiting for the receiving process. While receiving data is blocking
operation which stops the receiving process until the message has arrived.



Channel factory
===============

Channels may be created implicitly by the process output(s) declaration or explicitly using the following channel
factory methods.


create( )
---------

Creates a new `channel` by using the method ``create( )`` method, as showed below::

    myChannel = Channel.create()


from( )
-------

You can create transform any object that supports ``Iterable`` into a channel by using the ``from( )`` method.
Each iterable item is send over the newly created channel. For example::

    // creating a channel by a generic iterable object
    myChannel = Channel.from( myIterableObj )

    // creating a channel by a list
    myChannel = Channel.form( [1,2,3,4,5] )


Square brackets can be omitted when passing a list a parameter, thus the following example it is identical to the previous one::

     // square brackets can be omitted
     myChannel = Channel.form( 1,2,3,4,5 )



just( )
-------

This method create a dataflow `variable`, that is a channel to which is possible to bind at most entry. An optional,
not ``null`` value can be specified as parameters, which is bound to the newly created channel. For example::

    // creates am 'empty' variable
    myChannel = Channel.just()

    // creates a channel and bind a string to it
    myChannel = Channel.just( 'Hello there' )


    // creates a channel and bind a list object to it
    myChannel = Channel.just( [1,2,3,4,5] )



files( )
--------

You can create a channel emitting one or more files path by using the ``files( )`` method and specifying a path matcher
as argument. For example::

    myFileChannel = Channel.files( '/data/some/bigfile.txt' )

The above line creates a channel and bind to it an item of type ``Path`` referring the specified file.

.. note:: It does not care about file existence.

Whenever the ``files`` arguments contains a ``*`` or ``?`` wildcard characters it is interpreted as a `glob` path matcher.
For example::

    myFileChannel = Channel.files( '/data/big/*.txt' )


Creates a channel and sends over it as many ``Path`` items as many are the files with ``txt`` extension in the ``/data/big`` folder.

.. note:: As in Linux BASH the ``*`` wildcard does not match against hidden files (i.e. files which name starts a ``.`` character).

In order the include hidden files you need to start your pattern with a period character. For example::

    // returns all hidden files in the path
    myFileChannel = Channel.files( '/path/.*' )

    // returns all hidden files ending with .fa
    myFileChannel = Channel.files( '/path/.*.fa' )

    // returns all files (hidden and non-hidden)
    myFileChannel = Channel.files( '/path/{.*,*}' )



Binding values
==============

Since in `Nextflow` channels are implemented using `dataflow` variables or queues. Thus sending a message
is equivalent to `bind` a value to object representing the communication channel.

bind( )
-------

Channel objects provide a `bind( )` method which is the basic operation to send a message over the channel.
For example::

    myChannel = Channel.create()
    myChannel.bind( 'Hello world' )


operator <<
-----------

The operator ``<<`` is just a syntax sugar for the `bind( )` method. Thus, the following example produce
an identical result as the previous one::

    myChannel = Channel.create()
    myChannel << 'Hello world'


Special messages
================



STOP
----


VOID
----




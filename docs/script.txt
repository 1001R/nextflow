=================
Pipeline script
=================


The Nextflow scripting language is an extension of the Groovy programming language which syntax has been
specialized to ease the writing of computational pipeline in a declarative manner.

This means that Nextflow can execute any Groovy piece of code or use any library for the Java JVM platform.

Below you can find a crash course to the most important language constructs used by the Nextflow scripting language.

For a detailed description of the Groovy programming language, make references to these links:

* `Groovy User Guide <http://groovy.codehaus.org/User+Guide>`_
* `Groovy Cheat sheet <http://refcardz.dzone.com/refcardz/groovy>`_
* `Groovy in Action <http://www.manning.com/koenig2/>`_


Language basics
==================


Hello world
------------

To print something it's as easy as using the ``print`` or the ``println`` methods.
::

    println "Hello, World!"

The only different between the two is that the ``println`` method appends implicitly a `new line` character
to the entered string.


Variables
----------

To define a variable, simply assign a value to it. For example::

    x = 1
    println x

    x = new java.util.Date()
    println x

    x = -3.1499392
    println x

    x = false
    println x

    x = "Hi"
    println x


Lists
------

A List object can be defined by simply wrapping the list items by square brackets. For example::

    myList = [1776, -1, 33, 99, 0, 928734928763]

You can access a given item in the list with square bracket notation (indexes start at 0)::

    println myList[0]

In order to get the length of the list use the ``size`` method::

    println myList.size()


Learn more about lists:

* `Groovy Lists tutorial <http://groovy.codehaus.org/Collections#Collections-Lists>`_
* `Groovy List SDK <http://groovy.codehaus.org/groovy-jdk/java/util/List.html>`_
* `Java List SDK <http://docs.oracle.com/javase/7/docs/api/java/util/List.html>`_


Maps
-----

A map is used to store `associative arrays` or `dictionaries`. That is unordered collections of heterogeneous, named data.
For example::

    scores = [ "Brett":100, "Pete":"Did not finish", "Andrew":86.87934 ]


Note that each of the values stored in the map can be of a different type. Brett's is an integer, Pete's is a string,
and Andrew's is a floating point number.

We can access the values in a map in two main ways::

    println scores["Pete"]
    println scores.Pete


To modify or add data to a map, the syntax is similar to adding values to an list.
::

    scores["Pete"] = 3
    scores["Cedric"] = 120


Learn more about maps:

* `Groovy Maps tutorial <http://groovy.codehaus.org/Collections#Collections-maps>`_
* `Groovy Map SDK <http://groovy.codehaus.org/groovy-jdk/java/util/Map.html>`_
* `Java Map SDK <http://docs.oracle.com/javase/7/docs/api/java/util/Map.html>`_


Conditional Execution
----------------------

One of the most important features of any programming language is the ability to execute different code under
different conditions. The simplest way to do this is to use the ``if`` construct. For example::

    x = Math.random()
    if( x < 0.5 ) {
        println "You lost."
    }
    else {
        println "You won!"
    }



Strings
--------

Strings can be defined by delimiting them with a single-quote ``'`` or a double-quote ``"`` characters.
Using either type of string allows you to use strings with quotations easily
::

    println "he said 'cheese' once"
    println 'he said "cheese!" again'


Strings may be concatenated with "+". For example::

    a = "world"
    print "hello " + a + "\n"


String interpolation
----------------------

There is an important difference between single ``'`` and double ``"`` quoted strings. Double quoted string
supports variables interpolation, while single quoted strings do not.

In practice, strings that are declared inside double-quotes can contain arbitrary variables prefixing them with the ``$`` character
or any expressions by using the ``${expression}`` syntax in a very similar way to Bash/shell scripts.
::

    foxtype = 'quick'
    foxcolor = ['b', 'r', 'o', 'w', 'n']
    println "The $foxtype ${foxcolor.join()} fox"

    x = 'Hello'
    println '$x + $y'

It prints::

    The quick brown fox
    $x + $y


Multi-line strings
-------------------

Block of text that span multiple lines can be defined using

For example::

    name = "James"
    text = """
        hello there ${name}
        how are you today?
        """

.. note:: Like before, multi-line strings delimited by double-quotes characters supports variable interpolation, while
   single-quote string do not.


Like in Bash/shell scripts, by terminating a line into a multi-lines string with a ``\`` character, the resulting string is
not broken up::

    myLongCmdline = """ blastp \
                    -in $input_query \
                    -out $output_file \
                    -db $blast_database \
                    -html
                    """

    result = myLongCmdline.execute().text




Closures
=========

In very few words a closure is a block of code that can be passed as an argument to a function. That is you can define
a chunk of code and then pass it around as if it were a string or an integer.

More formally you can create functions that are first class objects.

::

    square = { it * it }


The curly braces around the expression ``it * it`` tells the Groovy compiler to treat this expression as code.
In this case, the designator ``it`` refers to whatever value is given to the function. Then this compiled function is
assigned to the variable `'square`` much like those above. So now we can do something like this::


    println square(9)

and get the value 81.


This is not very interesting until we find that we can pass this function ``square`` around as a method argument.
There are some built in functions that take a function like this as an argument. One example is the ``collect`` method on lists.
For example::

    [ 1, 2, 3, 4 ].collect(square)


This expression says, create an array with the values 1,2,3 and 4, then call the "collect" method, passing in the
closure we defined above. The collect method runs through each item in the array, calls the closure on the item,
then puts the result in a new array, resulting in:

    [ 1, 4, 9, 16 ]


For more methods you can call with closures as arguments, see the `Groovy GDK documentation <http://groovy.codehaus.org/groovy-jdk/>`_.


By default closures take 1 parameter called "it", you can also create closures with named parameters.
For example the method ``Map.each()`` can take a closure with two variables, to which it binds the `key` and the associated `value`::


    printMapClosure = { key, value ->
        println "$key = $value"
    }

    [ "Yue" : "Wu", "Mark" : "Williams", "sudha" : "Kumari" ].each(printMapClosure)


Prints::


    Yue=Wu
    Mark=Williams
    Sudha=Kumari





Closures have another two important features. First they can access variables in the scope where they are defined and
so they can `interact` with a variable (or more) outside itself.

The second thing is that a closure can be defined in a `anonymous` manner, meaning that it is not given a name,
and is defined in the place where the each method is called.

As example showing both this features is the following fragment::

    myMap = ["China": 1 , "India" : 2, "USA" : 3]

    result = 0
    myMap.keySet().each( { result+= myMap[it] } )

    println result










Regular expressions
====================

Regular expressions are the Swiss Army knife of text processing. They provide the programmer the ability to match
and extract patterns from strings.

Th


Capturing groups
----------------

Version parsing in #groovylang:
def (full, major, minor, patch, flavor) = (groovyVersion =~ /(\d+)\.(\d+)\.(\d+)-?(.+)/)[0]


Remove Part of String With Regular Expression
----------------------------------------------

You can subtract a part of a String value using a regular expression pattern. The first match found is
replaced with an empty String.

For example::

    // define the regexp pattern
    wordStartsWithGr = ~/(?i)\s+Gr\w+/

    // apply and verify the result
    ('Hello Groovy world!' - wordStartsWithGr) == 'Hello world!'
    ('Hi Grails users' - wordStartsWithGr) == 'Hi users'



Remove first match of a word with 5 characters::

    assert ('Remove first match of 5 letter word' - ~/\b\w{5}\b/) == 'Remove  match of 5 letter word'


Remove first found numbers followed by a whitespace character::

    assert ('Line contains 20 characters' - ~/\d+\s+/) == 'Line contains characters'

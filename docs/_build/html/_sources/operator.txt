########
Operator
########



split( )
--------

When a need comes to copy the output of a channel into more than one following channel, the ``split( )`` method will help you::

    source = Channel.from( 1,2,3 )
    copy1 = Channel.create()
    copy2 = Channel.create()

    source.split( copy1, copy2 )


In the above example, both channels ``copy1`` and ``copy2`` will get a values ``1``, ``2`` and ``3``


into( )
-------
TODO

tap( )
------
TODO

merge( )
--------


For example, the following code merges together two channels, one of which emits a series of odd integers and the other
of which emits a series of even integers::

    odds  = Channel.from([1, 3, 5, 7, 9]);
    evens = Channel.from([2, 4, 6]);

    odds.merge( evens ) { o, e -> [o, e] }
        .subscribe { println it }

::

    [1, 2]
    [3, 4]
    [5, 6]



separate( )
-----------
TODO

choice( )
---------
TODO

filter( )
---------

The ``filter( )`` operator allows you to filter data in the pipeline by using a boolean predicate. For example::

    Channel
        .from( 1, 2, 3, 4, 5 )
        .filter { it % 2 == 1 }
        .subscribe { println it }

::

    1
    3
    5


subscribe( )
------------

TODO

map( )
------

Transform the items emitted by a channel by applying a function to each of them. For example::

    Channel
        .from( 1, 2, 3, 4, ,5 )
        .map { it * it  }
        .subscribe onNext: { println it }, onComplete: { println 'Done' }

::

    1
    4
    9
    16
    25
    Done

mapWithIndex( )
---------------

Transform the items emitted by channel by applying a function to each of them that takes both the emitted item and
the numerical index of that item in the source sequence, so that you can refer to both when you apply your transformation.

For example::


    Channel
        .from( 'a', 'b', 'c' )
        .mapWithIndex { item, index ->  [item, index] }
        .subscribe onNext: { println it }, onComplete: { println 'Done' }


::

    [ 'a', 0 ]
    [ 'b', 1 ]
    [ 'c', 2 ]
    Done


mapMany( )
----------

Transform the items emitted by a channel by applying a function to each of them and then flattens the results of that function.


For example::

    // create a channel of numbers
    numbers = Channel.from( 1, 2, 3 )

    // map each number to a tuple (array), which items are emitted separately
    results = numbers.mapMany { n -> [ n*2, n*3 ] }

    // print the final results
    results.subscribe onNext: { println it }, onComplete: { println 'Done' }

::

    2
    3
    4
    6
    6
    9
    Done


Associative arrays are manged in the same way. Fo example::

    Channel.from ( 1, 2, 3 )
           .mapMany { it -> [ number: it, square: it*it ] }
           .subscribe { println it.key + ': ' + it.value }

::

    number: 1
    square: 1
    number: 2
    square: 4
    number: 3
    square: 9


reduce( )
---------

The ``reduce( )`` operator applies a function of your choosing to the first item emitted by a source channel,
then feeds the result of that function along with the second item emitted by the source channel into the same function,
then feeds the result of that function along with the third item into the same function, and so on until all items have been emitted by the source channel.

Finally it emits the final result from the final call to your function as the sole output from the returned channel.

For example::

    Channel
        .from( 1, 2, 3, 4, 5 )
        .reduce { a, b ->  a+b }
        .subscribe onNext: { println it }, onComplete: { println 'Done' }


::

    15
    Done

There is also a version of ``reduce( )`` to which you can pass a seed item in addition to an accumulator function::

    myChannel.reduce( seedValue ) {  a, b -> ... }


The seed value is used to initialize the accumulator argument i.e. the ``a`` argument in the above example.



grep( )
-------

The ``grep( )`` operator allows to filter a channel by discarding all item that do not meet the specified condition. The condition
can be a regular expression, a class, a literal value or a boolean expression.

Example using a regular expression::

    Channel
        .from( 'a', 'b', 'aa', 'bc', 3, 4.5 )
        .grep( ~/a+/ )
        .subscribe { println it }

::

    a
    aa


Example specifying the class ``Number`` to discard all but the numbers::

    Channel
        .from( 'a', 'b', 'aa', 'bc', 3, 4.5 )
        .grep( Number )
        .subscribe { println it }

::

    3
    4.5


Example using a boolean expression::

     Channel
         .from( 'a', 'b', 'aa', 'bc', 3, 4.5 )
         .grep { it.toString().size() == 1 }
         .subscribe { println it }

::

     a
     aa
     3

.. warning:: Note in the above example that the filtering expression is wrapped by curly brackets instead of normal
  round bracket, since it specifies a function (closure) passed as argument of the ``grep`` operator.


unique( )
---------

Use the ``unique( )`` operator to remove duplicate items from a source channel and only emit single items with no repetition.

For example::

    Channel
        .from( 1,1,1,5,7,7,7,3,3 )
        .unique()
        .subscribe { println it }

::

    1
    5
    7
    3


You can also specify an optional a function (closure) that customizes how it distinguishes between unique items.
For example ::

    Channel
        .from(1,3,4,5)
        .unique { it % 2 }
        .subscribe { println it }

::

    1
    4


distinct( )
-----------

Use the distinct( ) method to remove duplicate consecutive items from a source channel. For example::


    Channel
        .from( 1,1,2,2,2,3,1,1,2,2,3 )
        .distinct()
        .subscribe onNext: { println it }, onComplete: { println 'Done' }

::

    1
    2
    3
    1
    2
    3
    Done



You can also specify an optional a function (closure) that customizes how it distinguishes between distinct items.
For example::

    Channel
        .from( 1,1,2,2,2,3,1,1,2,4,6 )
        .distinct { it % 2 }
        .subscribe onNext: { println it }, onComplete: { println 'Done' }


::

    1
    2
    3
    2
    Done


first( )
--------

The ``first( )`` operator creates a channel that emits the first item emitted by the source channel, or the first
matching an optional condition. The condition can be a regular expression, a type or any closure evaluation a boolean expression. For example::


    // no condition is specified, emits the very first item: 1
    Channel
        .from( 1, 2, 3 )
        .first()
        .subscribe { println it }


    // emits the first String value: 'a'
    Channel
        .from( 1, 2, 'a', 'b', 3 )
        .first( String )
        .subscribe { println it }

    // emits the first item matching the regular expression: 'aa'
    Channel
        .from( 'a', 'aa', 'aaa' )
        .first( ~/aa.*/ )
        .subscribe { println it }

    // emits the first item for which the expression evaluates to true: 4
    Channel
        .from( 1,2,3,4,5 )
        .first { it > 3 }
        .subscribe { println it }


take( )
-------

The ``take( )`` emits only the first `n` items emitted by an channel. For example::

    Channel
        .from( 1,2,3,4,5,6 )
        .take( 3 )
        .subscribe onNext: { println it }, onComplete: { println 'Done' }

::

    1
    2
    3
    Done


last( )
-------

The ``last( )`` operator creates a channel that only emits the last item emitted by a source channel.


doFinally( )
------------

TODO

toList( )
---------

TODO


count( )
--------

The ``count( )`` operator creates a channel that emits a single item: a number that represents the total number of
items emitted by the source channel.

An optional parameter can be specified representing the condition to be satisfied by the item to count. For example::

        Channel
            .from(9,1,7,5)
            .count()
            .subscribe { println it }
        // -> 4


        Channel
            .from(4,1,7,1,1)
            .count(1)
            .subscribe { println it }
         // -> 3

        Channel
            .from('a','c','c','q','b')
            .count ( ~/c/ )
            .subscribe { println it }
        // -> 2


countBy( )
----------

The ``countBy( )`` creates a channel which emits an associative array (map object) counting the occurence of the emitted
items in the source channel. For example::

    Channel
        .from( 'x', 'y', 'x', 'x', 'z', 'y' )
        .countBy()
        .subscribe { println it }

::

    [x:3, y:2, z:1]


A optional grouping criteria can be specified by a function (closure) mapping each item to a grouping key. For example::


    Channel
        .from( 'hola', 'hello', 'ciao', 'bonjour', 'halo' )
        .countBy { it[0] }
        .subscribe { println it }


::

    [h:3, c:1, b:1]




min( )
------

max( )
------


sum( )
------

groupBy( )
----------

separate()
----------

rename it


spread( )
---------

flatten( )
----------

window()
--------

windowWithSizeConstraint( )
---------------------------

mix( )
------

phase( )
--------










